// Code generated DO NOT EDIT
// This code is AUTOGENERATED and will be overwritten by "go generate", so
// editing this file is a waste of time. To make changes, edit the template
// in pkg/generator/template/subcommand.tmpl. If you want to execute things
// before or after the command is executed, use a hook. See the usage_hook.go
// as an example.

package {{.Definition.Name|EscapePackage}}

{{- $identifierPath := ""}}
{{- if ne .Action.Identifier ""}}
    {{- if ne .Action.Identifier "nil"}}
        {{- $identifierPath = .Action.Identifier}}
    {{- end}}
{{- else}}
    {{- if ne .Definition.Identifier ""}}
        {{- $identifierPath = .Definition.Identifier}}
    {{- end}}
{{- end}}

{{- $subcommand := .Name}}

import (
    {{- if or (ne $identifierPath "") (HasPrefix .Action.APICall.Endpoint "List") }}"fmt"{{- end}}
	"buf.build/gen/go/gportal/gportal-cloud/grpc/go/gpcloud/api/{{.Action.APICall.Client}}/{{.Action.APICall.Version}}/{{.Action.APICall.Client}}{{.Action.APICall.Version}}grpc"
	{{.Action.APICall.Client}}{{.Action.APICall.Version}} "buf.build/gen/go/gportal/gportal-cloud/protocolbuffers/go/gpcloud/api/{{.Action.APICall.Client}}/{{.Action.APICall.Version}}"
	"google.golang.org/grpc"
	"encoding/json"
	{{- if HasHook .Definition.Name $subcommand "post"}}
	{{- end}}
    {{- if HasPrefix .Action.APICall.Endpoint "List" }}
	"reflect"
	"time"
	"fmt"
	"github.com/jedib0t/go-pretty/v6/table"
	"github.com/charmbracelet/ssh"
	{{- if eq (len .Action.Fields) 0}}
	{{- end}}
	{{- end}}
	"github.com/spf13/cobra"
	"github.com/G-PORTAL/gpcore-cli/pkg/config"
	"github.com/G-PORTAL/gpcore-cli/pkg/client"
	{{- range $i, $param := .Action.Params}}
    {{- if IsEnumType $param.Type}}
    "strings"
    {{- end}}
    {{- end}}
)


{{- if HasHook .Definition.Name $subcommand "pre"}}
{{ $subcommand|ToCamel|Title }}HookPre(resp, cmd)
{{- end}}

{{range $i, $param := .Action.Params}}
  {{- $datatype := $param.Type}}
  {{- if IsEnumType $param.Type}}
    {{- $datatype = "string"}}
  {{- end}}
var {{$subcommand|ToCamel}}{{$param.Name|ToCamel|Title}} {{$datatype}}
{{- end}}

{{- range $i, $param := .Action.Params}}
  {{- if IsEnumType $param.Type }}
  func {{$param.Type|StripPackage}}ToProto(a string) {{ $param.Type }} {
      for k, v := range {{ $param.Type}}_name {
          if v == "{{$param.Type|StripPackage|ToSnake|ToUpper}}_" + strings.ToUpper(a) {
              return {{ $param.Type}}(k)
          }
      }
      return {{ EnumToProto $param.Type "UNSPECIFIED" }}
  }
  {{- end}}
{{- end}}

var {{.Name|ToCamel}}Cmd = &cobra.Command{
	Use:                   "{{.Name}}",
	Short:                 "{{.Action.Description}}",
	Long:                  "{{.Action.Description}}",
	DisableFlagsInUseLine: true,
	Args:                  cobra.OnlyValidArgs,
	{{- if gt (len .Action.Params) 0}}
	ValidArgs: []string{
	    {{range $key, $value := .Action.Params}}"{{$value.Name|ToKebab}}",
	    {{- end}}
	},
	{{end}}
	RunE: func(cobraCmd *cobra.Command, args []string) error {
        ctx := client.ExtractContext(cobraCmd)

        {{- if ne $identifierPath ""}}
		session := ctx.Value("config").(*config.SessionConfig)
		if session == nil {
		    return fmt.Errorf("No session config in context")
		}
		if {{$identifierPath}} == nil {
		    return fmt.Errorf("Identifier not found in session config; ensure there is a project selected")
		}
        {{- end}}

		{{- if HasHook .Definition.Name $subcommand "pre"}}
		{{ $subcommand|ToCamel|Title }}HookPre(resp, cobraCmd)
		{{- end}}

        grpcConn := ctx.Value("conn").(*grpc.ClientConn)
        client := {{.Action.APICall.Client}}v1grpc.New{{.Action.APICall.Client|Title}}ServiceClient(grpcConn)
		resp, err := client.{{.Action.APICall.Endpoint}}(cobraCmd.Context(), &{{.Action.APICall.Client}}{{.Action.APICall.Version}}.{{.Action.APICall.Endpoint}}Request{
            {{- if ne .Action.Identifier ""}}
                {{- if ne .Action.Identifier "nil"}}
                // Custom identifier
                Id: *{{.Action.Identifier}},
                {{- end}}
            {{- else}}
                // Default identifier
                {{- if ne .Definition.Identifier ""}}
                Id:       *{{.Definition.Identifier}},
                {{- end}}
		    {{- end}}

	        {{- range $i, $param := .Action.Params}}
	          {{- if IsEnumType $param.Type}}
                {{$param.Name|ToCamel|Title}}: {{$param.Type|StripPackage|}}ToProto({{$subcommand|ToCamel}}{{$param.Name|ToCamel|Title}}{{")"}},
              {{- else }}
	            {{$param.Name|ToCamel|Title}}: {{ if and (not $param.Required) (eq $param.Default nil) }}&{{end}}{{$subcommand|ToCamel}}{{$param.Name|ToCamel|Title}},
              {{- end}}
	        {{- end}}
		})
		if err != nil {
			return err
		}

		{{- if HasHook .Definition.Name $subcommand "post"}}
		respHook, err := {{ $subcommand|ToCamel|Title }}HookPost(resp, cobraCmd)
		if err != nil {
		    return err
		}
		{{- end}}

        {{- if HasPrefix .Action.APICall.Endpoint "List" }}
		sshSession := ctx.Value("ssh").(*ssh.Session)
        // Remove root key
        {{ $rootKey := .Action.RootKey }}
		{{- if eq .Action.RootKey ""}}
        {{ $rootKey = .Name|Pluralize|ToCamel|Title}}
        {{- end}}

		respData := resp.{{$rootKey}}

		// Build the table
		headerRow := table.Row{}

		tbl := table.NewWriter()
		tbl.SetStyle(table.StyleRounded)
		tbl.SetOutputMirror(*sshSession)
		cobraCmd.SetOut(*sshSession)

		{{- if eq (len .Action.Fields) 0}}
		for j, entry := range respData {
			// Use all fields
			c := reflect.ValueOf(*entry)
			row := table.Row{}

			for i := 0; i < c.NumField(); i++ {
				// Skip all unexported fields
				if c.Type().Field(i).IsExported() {
				    val := fmt.Sprintf("%v", c.Field(i).Interface())

                    // Custom fields?
                    // TODO: Remove duplicate code
			        col := fmt.Sprintf("%v", c.Type().Field(i).Name)
			        switch col {
			        case "CreatedAt":
			            // This one is tricky. We need to get the seconds from the struct
			            // and convert it to a time.Time object. Problem is the Go type system
			            // and the fact that we don't know the type of the field. So we need to
			            // use reflection to get the value and then convert it to a time.Time.
			            // A lib like Jennifer would be better suited for this.
			            a := reflect.Indirect(c.FieldByName("CreatedAt"))
			            s := reflect.Indirect(a).FieldByName("Seconds")
			            if s.CanInt() {
			                t := time.Unix(s.Int(), 0)
                            val = t.Format("2006-01-02 15:04:05")
                        }
                    case "Currency":
                        val = val[9:]
                    case "Environment":
                        val = val[20:]
			        }

					row = append(row, val)

					if j == 0 {
						headerRow = append(headerRow, c.Type().Field(i).Name)
					}
				}
			}
			tbl.AppendRow(row)
		}

        {{- range $key, $value := .Action.Fields}}
        headerRow = append(headerRow, "{{$value|Title}}")
        {{- end}}
		tbl.AppendHeader(headerRow)

		{{- else }}
		// Only use whitelist fields
		{{- $name := .Definition.Name}}
		for i, entry := range respData {
            row := make([]interface{}, 0)
			c := reflect.ValueOf(*entry)
            val := ""
            col := ""

            {{- range $key, $value := .Action.Fields}}
            // The field from the res
            val = fmt.Sprintf("%v", entry.{{$value|Title}})

		    {{- if HasHook $name $subcommand "post"}}
            if v, ok := respHook[i]["{{$value|Title}}"]; ok {
                // We do have a custom hook field
                val = v
            }
            {{- end}}

            // Custom fields?
            // TODO: Remove duplicate code.
			col = "{{$value|Title}}"
			switch col {
			case "CreatedAt":
			    // This one is tricky. We need to get the seconds from the struct
			    // and convert it to a time.Time object. Problem is the Go type system
			    // and the fact that we don't know the type of the field. So we need to
			    // use reflection to get the value and then convert it to a time.Time.
			    // A lib like Jennifer would be better suited for this.
			    a := reflect.Indirect(c.FieldByName("CreatedAt"))
			    s := reflect.Indirect(a).FieldByName("Seconds")
			    if s.CanInt() {
			        t := time.Unix(s.Int(), 0)
                    val = t.Format("2006-01-02 15:04:05")
                }
            case "Currency":
                val = val[9:]
            case "Environment":
                val = val[20:]
			}

            row = append(row, val)
            if i == 0 {
                headerRow = append(headerRow, "{{$value|Title}}")
            }
            {{- end}}

            tbl.AppendRow(row)
        }
		tbl.AppendHeader(headerRow)
		{{- end}}

		if config.CSVOutput {
            tbl.RenderCSV()
            return nil
        }

		if !config.JSONOutput {
            tbl.Render()
        }

		{{- else}}
		// Single response
		respData := resp
        {{- end}}

		if config.JSONOutput {
			jsonData, err := json.MarshalIndent(respData, "", "  ")
			if err != nil {
				return err
			}
			cobraCmd.Println(string(jsonData))
		}

		return nil
	},
}

func init() {
    {{- range $i, $param := .Action.Params}}
    {{- $datatypeDefaultValue := $param|DefaultValue}}
    {{- $datatype := $param.Type|Title}}
    {{- if IsEnumType $param.Type}}
      {{$datatype = "String"}}
    {{- end}}

    {{$subcommand|ToCamel}}Cmd.Flags().{{$datatype}}Var(&{{$subcommand|ToCamel}}{{$param.Name|ToCamel|Title}}, "{{$param.Name|ToKebab}}", {{$datatypeDefaultValue}}, "{{$param|ParameterDescription}}")

    {{- if $param.Required}}
    {{$subcommand|ToCamel}}Cmd.MarkFlagRequired("{{$param.Name}}")
    {{- end}}
    {{- end}}


	Root{{.Definition.Name|Title}}Command.AddCommand({{$subcommand|ToCamel}}Cmd)
}
