package generator

import (
	"fmt"
	"github.com/charmbracelet/log"
	. "github.com/dave/jennifer/jen"
	"github.com/gertd/go-pluralize"
	"github.com/stoewer/go-strcase"
	"os"
	"regexp"
	"strings"
)

var protoHelpersAdded = make([]string, 0)
var arrayDatatypes = make([]string, 0)

// warningComment adds a warning comment to the file. This will be added to all
// generated files to warn the developer that the file is autogenerated and
// should not be edited.
func warningComment(f *File) {
	f.HeaderComment("Code generated DO NOT EDIT")
	f.HeaderComment("This code is AUTOGENERATED and will be overwritten by \"go generate\", so")
	f.HeaderComment("editing this file is a waste of time. To make changes, edit the template")
	f.HeaderComment("in pkg/generator/template/subcommand.tmpl. If you want to execute things")
	f.HeaderComment("before or after the command is executed, use a hook. See the usage_hook.go")
	f.HeaderComment("as an example.")
	f.Line()
}

// enumToProtoFunc generates a function which converts a string to a proto enum
// to be used it in the API call.
func enumToProtoFunc(enumType string) []Code {
	c := make([]Code, 0)

	// Generate the function
	c = append(c, Func().Id(stripPackage(enumType)+"ToProto").Params(
		Id("a").String()).Qual(clientPackageName(enumType), stripPackage(enumType)).Block(
		For(List(Id("k"), Id("v")).Op(":=").Range().Id(enumType+"_name").Block(
			If(Id("v").Op("==").
				Lit(strings.ToUpper(strcase.SnakeCase(stripPackage(enumType)))+"_").
				Op("+").
				Qual("strings", "ToUpper").Call(Id("a"))).Block(
				Return(Id(enumType).Call(Id("k"))))),
			Return(Id(enumToProtoType(enumType, "UNSPECIFIED"))))))

	return c
}

// generateArrayDatatype generates a datatype for an array of a given datatype.
// This is needed for complex datatypes like array of enums.
func generateArrayDatatype(datatype string) []Code {
	c := make([]Code, 0)

	typeName := strcase.UpperCamelCase(stripPackage(datatype)) + "Array"
	c = append(c, Type().Id(typeName).Index().Qual(clientPackageName(datatype), stripPackage(datatype)))

	// XXX: Not sure why jennifer need a newline in front of the function here.
	// looks like a jennifer bug to me, but it is not worth to investigate this
	// at that stage.
	c = append(c, Line().Func().Params(Id("t").Op("*").Id(typeName)).
		Id("String").Params().
		String().
		Block(
			Id("res").Op(":=").Lit(""),
			For(List(Id("_"), Id("item")).Op(":=").Range().Op("*").Id("t")).
				Block(
					Id("res").Op("+=").Id("item").Dot("String").Call().Op("+").Lit(", "),
				),
			Return(Id("res")),
		))

	c = append(c, Line().Func().Params(Id("t").Op("*").Id(typeName)).
		Id("Set").
		Params(Id("value").String()).
		Error().
		Block(
			Id("items").Op(":=").Qual("strings", "Split").Call(Id("value"), Lit(",")),
			Id("res").Op(":=").Op("*").Id("t"),
			For(List(Id("_"), Id("item")).Op(":=").Range().Id("items")).
				Block(
					Id("res").Op("=").Append(Id("res"),
						Id(stripPackage(datatype)+"ToProto").Call(Id("item"))),
				),
			Id("*t").Op("=").Id("res"),
			Return(Nil()),
		))

	c = append(c, Line().Func().Params(Id("t").Op("*").Id(typeName)).
		Id("Type").
		Params().
		String().
		Block(
			Return(Lit(stripPackage(datatype))),
		))

	return c
}

// GenerateHelpersFile generates a helpers file which contains helper functions
// for the API calls. This is needed to convert complex datatypes like enums to
// proto enums.
func GenerateHelpersFile(targetFilename string) error {
	f := NewFile("protobuf")
	warningComment(f)

	log.Printf("Generate helpers file %s", targetFilename)

	// Add the enumToProtoFunc
	for _, enumType := range protoHelpersAdded {
		log.Printf("  Add enumToProtoFunc for %s", enumType)
		f.ImportAlias(clientPackageName(enumType), stripClient(enumType)+"v"+stripVersion(enumType))
		f.Add(enumToProtoFunc(enumType)...)
	}

	f.Line()

	// Add the array datatypes
	for _, datatype := range arrayDatatypes {
		log.Printf("  Add array datatype for %s", datatype)
		f.Add(generateArrayDatatype(datatype)...)
	}

	return f.Save(targetFilename)
}

// hasListOutput checks if a given API call has a list output. This is the case
// if the endpoint starts with "List" or if the API call supports pagination.
// This can be used to determine the output format (table or just a single object).
func hasListOutput(apiCall APICall) bool {
	return strings.HasPrefix(apiCall.Endpoint, "List")
}

// hasHook checks if a hook exists for a given command and subcommand. A hook is
// a file in format cmd/{command}/{subcommand}_{hookType}.go. If the file exists
// the hook will be added to the generated code.
func hasHook(command string, subcommand string, hookType string) bool {
	if _, err := os.Stat("./cmd/" + command + "/" + subcommand + "_" + hookType + ".go"); !os.IsNotExist(err) {
		log.Printf("  Include hook %s/%s for type %s", command, subcommand, hookType)
		return true
	}
	return false
}

// addHook adds a hook to the generated code.
func addHook(name string, hookType string) []Code {
	var c []Code
	fName := strings.Title(name) + "Hook" + strcase.UpperCamelCase(hookType)
	c = append(c, Qual("", fName).Call(Id("resp"), Id("cmd")))
	return c
}

// title converts a string to title case.
func title(s string) string {
	return strings.Title(strcase.LowerCamelCase(s))
}

// plural converts a string to plural case.
func plural(s string) string {
	pl := pluralize.NewClient()
	return strings.ToLower(pl.Plural(s))
}

// isEnumType checks if a string is an enum type. An enum type is a string
// containing a dot.
func isEnumType(s string) bool {
	return strings.Contains(s, ".")
}

// isArrayType checks if a string is an array type. An array type is a string
// starting with "[]". isArrayType and isEnumType can be combined to check if
// a string is an array of enums.
func isArrayType(s string) bool {
	return strings.HasPrefix(s, "[]")
}

// enumToProtoType converts an enum type to a prototype.
func enumToProtoType(enumType string, value string) string {
	// cloudv1.ProjectEnvironment -> ProjectEnvironment_PROJECT_ENVIRONMENT_[VALUE]
	parts := strings.Split(enumType, ".")
	return parts[0] + "." + parts[1] + "_" + strcase.UpperSnakeCase(parts[1]) + "_" + strings.ToUpper(value)
}

// defaultValue returns the default value for a given parameter as a
// *Statement. If the parameter has no default value, nil is returned.
func defaultValue(param Param) *Statement {
	if param.Default == nil {
		// TODO: Fileupload
		switch param.Type {
		case "string":
			return Lit("")
		case "bool":
			return Lit(false)
		case "int":
			return Lit(0)
		case "int32":
			return Lit(int32(0))
		case "int64":
			return Lit(int64(0))
		default:
			if isArrayType(param.Type) {
				return Index().Id(strings.TrimPrefix(param.Type, "[]")).Values(Dict{})
			}
		}
	} else {
		// TODO: Fileupload
		switch param.Type {
		case "string":
			return Lit(fmt.Sprintf("%s", param.Default))
		case "bool":
			return Lit(param.Default.(bool))
		case "int":
			return Lit(param.Default.(int))
		case "int32":
			return Lit(int32(param.Default.(int)))
		case "int64":
			return Lit(int64(param.Default.(int)))
		default:
			if isEnumType(param.Type) {
				parts := strings.Split(param.Default.(string), "_")
				return Lit(parts[len(parts)-1])
			}

			if isArrayType(param.Type) {
				// TODO: Add default values from definition
				return Index().Id(strings.TrimPrefix(param.Type, "[]")).Values(Dict{})
			}
		}
	}

	// We need to take care of the array datatype, because we do not need a
	// default value for it.

	return Lit(nil)
}

// parameterDescription returns the description of a parameter. If the parameter
// has a default value, the default value is added to the description.
func parameterDescription(param Param) string {
	var flags []string
	if param.Required {
		flags = append(flags, "required")
	}

	if len(flags) > 0 {
		return fmt.Sprintf("%s (%s)", param.Description, strings.Join(flags, ", "))
	}
	return param.Description
}

// stripPackage removes the package name from a string. This is needed to
// generate valid variable names (without package names).
func stripPackage(s string) string {
	return strings.Split(s, ".")[1]
}

func clientPackageName(s string) string {
	return "buf.build/gen/go/gportal/gpcore/protocolbuffers/go/gpcore/api/" + stripClient(s) + "/v" + stripVersion(s)
}

func stripVersion(s string) string {
	re := regexp.MustCompile(`.+v(\d+)\..+`)
	matches := re.FindStringSubmatch(s)
	if len(matches) == 2 {
		return matches[1]
	}

	return "1"
}

func stripClient(s string) string {
	re := regexp.MustCompile(`(.+)v([1-9]+)?\..+`)
	matches := re.FindStringSubmatch(s)
	if len(matches) <= 3 && len(matches) > 1 {
		return matches[1]
	}

	return ""
}

// escapePackage replaces dots and dashes with underscores. This is needed to
// set valid variable names (without dots and dashes).
func escapePackage(name string) string {
	return strings.Replace(strings.Replace(name, ".", "_", -1), "-", "_", -1)
}

// apiClient returns the string representation of the API client for a given
// subcommand.
func apiClient(metadata SubcommandMetadata) string {
	return metadata.Action.APICall.Client + metadata.Action.APICall.Version
}
