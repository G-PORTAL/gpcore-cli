package generator

import (
	"fmt"
	"github.com/charmbracelet/log"
	. "github.com/dave/jennifer/jen"
	"github.com/gertd/go-pluralize"
	"github.com/stoewer/go-strcase"
	"os"
	"strings"
)

// paginatedEndpoints is a list of all endpoints which already supports pagination.
// When the pagination MR for gpcore-mono is merged into master, we can remove
// this list and use all endpoints which start with "List".
var paginatedEndpoints = []string{
	// Admin
	"ListServers",
	"ListServerLogs",
	"ListSwitches",
	"ListUsers",
	"ListUserBills",
	"ListAdminLogs",
	"ListIPHistories",

	// Cloud
	"ListBillingProfileBills",
	"ListBillingProfileProjects",
	"ListProjectLogs",
	"ListNodes",
}

// warningComment adds a warning comment to the file. This will be added to all
// generated files to warn the developer that the file is autogenerated and
// should not be edited.
func warningComment(f *File) {
	f.HeaderComment("Code generated DO NOT EDIT")
	f.HeaderComment("This code is AUTOGENERATED and will be overwritten by \"go generate\", so")
	f.HeaderComment("editing this file is a waste of time. To make changes, edit the template")
	f.HeaderComment("in pkg/generator/template/subcommand.tmpl. If you want to execute things")
	f.HeaderComment("before or after the command is executed, use a hook. See the usage_hook.go")
	f.HeaderComment("as an example.")
	f.Line()
}

// hasPaginateField checks if a given API call supports pagination with the
// Pagination field in request and response.
func hasPaginateField(apiCall APICall) bool {
	// TODO: After the pagination MR for gpcore-mono is merged into master,
	// we can change this to all list endpoints which start with "List". But
	// until then, we need to whitelist the endpoints which support pagination.
	for _, endpoint := range paginatedEndpoints {
		if apiCall.Endpoint == endpoint {
			return true
		}
	}

	return false
}

// hasListOutput checks if a given API call has a list output. This is the case
// if the endpoint starts with "List" or if the API call supports pagination.
// This can be used to determine the output format (table or just a single object).
func hasListOutput(apiCall APICall) bool {
	return hasPaginateField(apiCall) || strings.HasPrefix(apiCall.Endpoint, "List")
}

// hasHook checks if a hook exists for a given command and subcommand. A hook is
// a file in format cmd/{command}/{subcommand}_{hookType}.go. If the file exists
// the hook will be added to the generated code.
func hasHook(command string, subcommand string, hookType string) bool {
	if _, err := os.Stat("./cmd/" + command + "/" + subcommand + "_" + hookType + ".go"); !os.IsNotExist(err) {
		log.Printf("  Include hook %s/%s for type %s", command, subcommand, hookType)
		return true
	}
	return false
}

// addHook adds a hook to the generated code.
func addHook(name string, hookType string) []Code {
	var c []Code
	fName := strings.Title(name) + "Hook" + strcase.UpperCamelCase(hookType)
	c = append(c, Qual("", fName).Call(Id("resp"), Id("cmd")))
	return c
}

// title converts a string to title case.
func title(s string) string {
	return strings.Title(strcase.LowerCamelCase(s))
}

// plural converts a string to plural case.
func plural(s string) string {
	pl := pluralize.NewClient()
	return strings.ToLower(pl.Plural(s))
}

// enumType checks if a string is an enum type. An enum type is a string
// containing a dot.
func enumType(s string) bool {
	return strings.Contains(s, ".")
}

// enumToProtoType converts an enum type to a proto type.
func enumToProtoType(enumType string, value string) string {
	// cloudv1.ProjectEnvironment -> ProjectEnvironment_PROJECT_ENVIRONMENT_[VALUE]
	parts := strings.Split(enumType, ".")
	return parts[0] + "." + parts[1] + "_" + strcase.UpperSnakeCase(parts[1]) + "_" + strings.ToUpper(value)
}

// defaultValue returns the default value for a given parameter as a
// *Statement. If the parameter has no default value, nil is returned.
func defaultValue(param Param) *Statement {
	if param.Default == nil {
		switch param.Type {
		case "string":
			return Lit("")
		case "bool":
			return Lit(false)
		case "int":
			return Lit(0)
		}
	} else {
		switch param.Type {
		case "string":
			return Lit(fmt.Sprintf("%s", param.Default))
		case "bool":
			return Lit(param.Default.(bool))
		case "int":
			return Lit(param.Default.(int))
		default: // enum
			if strings.Contains(param.Default.(string), ".") {
				parts := strings.Split(param.Default.(string), "_")

				return Lit(parts[len(parts)-1])
			}
		}
	}

	return Lit(nil)
}

// parameterDescription returns the description of a parameter. If the parameter
// has a default value, the default value is added to the description.
func parameterDescription(param Param) string {
	var flags []string
	if param.Default == nil {
		if param.Required {
			flags = append(flags, "required")
		}
	} else {
		flags = append(flags, fmt.Sprintf("default:\"%v\"", param.Default))
	}

	if len(flags) > 0 {
		return fmt.Sprintf("%s (%s)", param.Description, strings.Join(flags, ", "))
	}
	return param.Description
}

// stripPackage removes the package name from a string. This is needed to
// generate valid variable names (without package names).
func stripPackage(s string) string {
	return strings.Split(s, ".")[1]
}

// escapePackage replaces dots and dashes with underscores. This is needed to
// set valid variable names (without dots and dashes).
func escapePackage(name string) string {
	return strings.Replace(strings.Replace(name, ".", "_", -1), "-", "_", -1)
}

// apiClient returns the string representation of the API client for a given
// subcommand.
func apiClient(metadata SubcommandMetadata) string {
	return metadata.Action.APICall.Client + metadata.Action.APICall.Version
}
